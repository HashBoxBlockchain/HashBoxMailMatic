class Encoder{constructor(name,prefix,baseEncode){this.name=name;this.prefix=prefix;this.baseEncode=baseEncode}encode(bytes){if(bytes instanceof Uint8Array){return`${this.prefix}${this.baseEncode(bytes)}`}else{throw Error("Unknown type, must be binary type")}}}class Decoder{constructor(name,prefix,baseDecode){this.name=name;this.prefix=prefix;if(prefix.codePointAt(0)===undefined){throw new Error("Invalid prefix character")}this.prefixCodePoint=prefix.codePointAt(0);this.baseDecode=baseDecode}decode(text){if(typeof text==="string"){if(text.codePointAt(0)!==this.prefixCodePoint){throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)}return this.baseDecode(text.slice(this.prefix.length))}else{throw Error("Can only multibase decode strings")}}or(decoder){return or(this,decoder)}}class ComposedDecoder{constructor(decoders){this.decoders=decoders}or(decoder){return or(this,decoder)}decode(input){const prefix=input[0];const decoder=this.decoders[prefix];if(decoder){return decoder.decode(input)}else{throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}}export const or=(left,right)=>new ComposedDecoder({...left.decoders||{[left.prefix]:left},...right.decoders||{[right.prefix]:right}});export class Codec{constructor(name,prefix,baseEncode,baseDecode){this.name=name;this.prefix=prefix;this.baseEncode=baseEncode;this.baseDecode=baseDecode;this.encoder=new Encoder(name,prefix,baseEncode);this.decoder=new Decoder(name,prefix,baseDecode)}encode(input){return this.encoder.encode(input)}decode(input){return this.decoder.decode(input)}}export const from=({name,prefix,encode,decode})=>new Codec(name,prefix,encode,decode);export const baseX=({prefix,name,alphabet})=>{const{encode,decode}=base(alphabet,name);return from({prefix:prefix,name:name,encode:encode,decode:text=>coerce(decode(text))})};const decode=(string,alphabet,bitsPerChar,name)=>{const codes={};for(let i=0;i<alphabet.length;++i){codes[alphabet[i]]=i}let end=string.length;while(string[end-1]==="="){--end}const out=new Uint8Array(end*bitsPerChar/8|0);let bits=0;let buffer=0;let written=0;for(let i=0;i<end;++i){const value=codes[string[i]];if(value===undefined){throw new SyntaxError(`Non-${name} character`)}buffer=buffer<<bitsPerChar|value;bits+=bitsPerChar;if(bits>=8){bits-=8;out[written++]=255&buffer>>bits}}if(bits>=bitsPerChar||255&buffer<<8-bits){throw new SyntaxError("Unexpected end of data")}return out};const encode=(data,alphabet,bitsPerChar)=>{const pad=alphabet[alphabet.length-1]==="=";const mask=(1<<bitsPerChar)-1;let out="";let bits=0;let buffer=0;for(let i=0;i<data.length;++i){buffer=buffer<<8|data[i];bits+=8;while(bits>bitsPerChar){bits-=bitsPerChar;out+=alphabet[mask&buffer>>bits]}}if(bits){out+=alphabet[mask&buffer<<bitsPerChar-bits]}if(pad){while(out.length*bitsPerChar&7){out+="="}}return out};export const rfc4648=({name,prefix,bitsPerChar,alphabet})=>{return from({prefix:prefix,name:name,encode(input){return encode(input,alphabet,bitsPerChar)},decode(input){return decode(input,alphabet,bitsPerChar,name)}})};export const base32=rfc4648({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5});export const base32upper=rfc4648({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5});export const base32pad=rfc4648({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5});export const base32padupper=rfc4648({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5});export const base32hex=rfc4648({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5});export const base32hexupper=rfc4648({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5});export const base32hexpad=rfc4648({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5});export const base32hexpadupper=rfc4648({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5});export const base32z=rfc4648({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});export const base58btc=baseX({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"});export const base58flickr=baseX({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});function base(ALPHABET,name){if(ALPHABET.length>=255){throw new TypeError("Alphabet too long")}var BASE_MAP=new Uint8Array(256);for(var j=0;j<BASE_MAP.length;j++){BASE_MAP[j]=255}for(var i=0;i<ALPHABET.length;i++){var x=ALPHABET.charAt(i);var xc=x.charCodeAt(0);if(BASE_MAP[xc]!==255){throw new TypeError(x+" is ambiguous")}BASE_MAP[xc]=i}var BASE=ALPHABET.length;var LEADER=ALPHABET.charAt(0);var FACTOR=Math.log(BASE)/Math.log(256);var iFACTOR=Math.log(256)/Math.log(BASE);function encode(source){if(source instanceof Uint8Array);else if(ArrayBuffer.isView(source)){source=new Uint8Array(source.buffer,source.byteOffset,source.byteLength)}else if(Array.isArray(source)){source=Uint8Array.from(source)}if(!(source instanceof Uint8Array)){throw new TypeError("Expected Uint8Array")}if(source.length===0){return""}var zeroes=0;var length=0;var pbegin=0;var pend=source.length;while(pbegin!==pend&&source[pbegin]===0){pbegin++;zeroes++}var size=(pend-pbegin)*iFACTOR+1>>>0;var b58=new Uint8Array(size);while(pbegin!==pend){var carry=source[pbegin];var i=0;for(var it1=size-1;(carry!==0||i<length)&&it1!==-1;it1--,i++){carry+=256*b58[it1]>>>0;b58[it1]=carry%BASE>>>0;carry=carry/BASE>>>0}if(carry!==0){throw new Error("Non-zero carry")}length=i;pbegin++}var it2=size-length;while(it2!==size&&b58[it2]===0){it2++}var str=LEADER.repeat(zeroes);for(;it2<size;++it2){str+=ALPHABET.charAt(b58[it2])}return str}function decodeUnsafe(source){if(typeof source!=="string"){throw new TypeError("Expected String")}if(source.length===0){return new Uint8Array}var psz=0;if(source[psz]===" "){return}var zeroes=0;var length=0;while(source[psz]===LEADER){zeroes++;psz++}var size=(source.length-psz)*FACTOR+1>>>0;var b256=new Uint8Array(size);while(source[psz]){var carry=BASE_MAP[source.charCodeAt(psz)];if(carry===255){return}var i=0;for(var it3=size-1;(carry!==0||i<length)&&it3!==-1;it3--,i++){carry+=BASE*b256[it3]>>>0;b256[it3]=carry%256>>>0;carry=carry/256>>>0}if(carry!==0){throw new Error("Non-zero carry")}length=i;psz++}if(source[psz]===" "){return}var it4=size-length;while(it4!==size&&b256[it4]===0){it4++}var vch=new Uint8Array(zeroes+(size-it4));var j=zeroes;while(it4!==size){vch[j++]=b256[it4++]}return vch}function decode(string){var buffer=decodeUnsafe(string);if(buffer){return buffer}throw new Error(`Non-${name} character`)}return{encode:encode,decodeUnsafe:decodeUnsafe,decode:decode}}var src=base;var _brrp__multiformats_scope_baseX=src;const empty=new Uint8Array(0);const toHex=d=>d.reduce((hex,byte)=>hex+byte.toString(16).padStart(2,"0"),"");const fromHex=hex=>{const hexes=hex.match(/../g);return hexes?new Uint8Array(hexes.map(b=>parseInt(b,16))):empty};const equalBytes=(aa,bb)=>{if(aa===bb)return true;if(aa.byteLength!==bb.byteLength){return false}for(let ii=0;ii<aa.byteLength;ii++){if(aa[ii]!==bb[ii]){return false}}return true};const coerce=o=>{if(o instanceof Uint8Array&&o.constructor.name==="Uint8Array")return o;if(o instanceof ArrayBuffer)return new Uint8Array(o);if(ArrayBuffer.isView(o)){return new Uint8Array(o.buffer,o.byteOffset,o.byteLength)}throw new Error("Unknown type, must be binary type")};const isBinary=o=>o instanceof ArrayBuffer||ArrayBuffer.isView(o);const fromString=str=>(new TextEncoder).encode(str);const toString=b=>(new TextDecoder).decode(b);export{equalBytes,coerce,isBinary,fromHex,toHex,fromString,toString,empty};export class CID{constructor(version,code,multihash,bytes){this.code=code;this.version=version;this.multihash=multihash;this.bytes=bytes;this.byteOffset=bytes.byteOffset;this.byteLength=bytes.byteLength;this.asCID=this;this._baseCache=new Map;Object.defineProperties(this,{byteOffset:hidden,byteLength:hidden,code:readonly,version:readonly,multihash:readonly,bytes:readonly,_baseCache:hidden,asCID:hidden})}toV0(){switch(this.version){case 0:{return this}default:{const{code,multihash}=this;if(code!==DAG_PB_CODE){throw new Error("Cannot convert a non dag-pb CID to CIDv0")}if(multihash.code!==SHA_256_CODE){throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0")}return CID.createV0(multihash)}}}toV1(){switch(this.version){case 0:{const{code,digest}=this.multihash;const multihash=digest_create(code,digest);return CID.createV1(this.code,multihash)}case 1:{return this}default:{throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}}equals(other){return other&&this.code===other.code&&this.version===other.version&&digest_equals(this.multihash,other.multihash)}toString(base){const{bytes,version,_baseCache}=this;switch(version){case 0:return toStringV0(bytes,_baseCache,base||base58btc.encoder);default:return toStringV1(bytes,_baseCache,base||base32.encoder)}}toJSON(){return{code:this.code,version:this.version,hash:this.multihash.bytes}}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return"CID("+this.toString()+")"}static isCID(value){deprecate(/^0\.0/,IS_CID_DEPRECATION);return!!(value&&(value[cidSymbol]||value.asCID===value))}get toBaseEncodedString(){throw new Error("Deprecated, use .toString()")}get codec(){throw new Error('"codec" property is deprecated, use integer "code" property instead')}get buffer(){throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead")}get multibaseName(){throw new Error('"multibaseName" property is deprecated')}get prefix(){throw new Error('"prefix" property is deprecated')}static asCID(value){if(value instanceof CID){return value}else if(value!=null&&value.asCID===value){const{version,code,multihash,bytes}=value;return new CID(version,code,multihash,bytes||encodeCID(version,code,multihash.bytes))}else if(value!=null&&value[cidSymbol]===true){const{version,multihash,code}=value;const digest=digest_decode(multihash);return CID.create(version,code,digest)}else{return null}}static create(version,code,digest){if(typeof code!=="number"){throw new Error("String codecs are no longer supported")}switch(version){case 0:{if(code!==DAG_PB_CODE){throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`)}else{return new CID(version,code,digest,digest.bytes)}}case 1:{const bytes=encodeCID(version,code,digest.bytes);return new CID(version,code,digest,bytes)}default:{throw new Error("Invalid version")}}}static createV0(digest){return CID.create(0,DAG_PB_CODE,digest)}static createV1(code,digest){return CID.create(1,code,digest)}static decode(bytes){const[cid,remainder]=CID.decodeFirst(bytes);if(remainder.length){throw new Error("Incorrect length")}return cid}static decodeFirst(bytes){const specs=CID.inspectBytes(bytes);const prefixSize=specs.size-specs.multihashSize;const multihashBytes=coerce(bytes.subarray(prefixSize,prefixSize+specs.multihashSize));if(multihashBytes.byteLength!==specs.multihashSize){throw new Error("Incorrect length")}const digestBytes=multihashBytes.subarray(specs.multihashSize-specs.digestSize);const digest=new Digest(specs.multihashCode,specs.digestSize,digestBytes,multihashBytes);const cid=specs.version===0?CID.createV0(digest):CID.createV1(specs.codec,digest);return[cid,bytes.subarray(specs.size)]}static inspectBytes(initialBytes){let offset=0;const next=()=>{const[i,length]=varint_decode(initialBytes.subarray(offset));offset+=length;return i};let version=next();let codec=DAG_PB_CODE;if(version===18){version=0;offset=0}else if(version===1){codec=next()}if(version!==0&&version!==1){throw new RangeError(`Invalid CID version ${version}`)}const prefixSize=offset;const multihashCode=next();const digestSize=next();const size=offset+digestSize;const multihashSize=size-prefixSize;return{version:version,codec:codec,multihashCode:multihashCode,digestSize:digestSize,multihashSize:multihashSize,size:size}}static parse(source,base){const[prefix,bytes]=parseCIDtoBytes(source,base);const cid=CID.decode(bytes);cid._baseCache.set(prefix,source);return cid}}const parseCIDtoBytes=(source,base)=>{switch(source[0]){case"Q":{const decoder=base||base58btc;return[base58btc.prefix,decoder.decode(`${base58btc.prefix}${source}`)]}case base58btc.prefix:{const decoder=base||base58btc;return[base58btc.prefix,decoder.decode(source)]}case base32.prefix:{const decoder=base||base32;return[base32.prefix,decoder.decode(source)]}default:{if(base==null){throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided")}return[source[0],base.decode(source)]}}};const toStringV0=(bytes,cache,base)=>{const{prefix}=base;if(prefix!==base58btc.prefix){throw Error(`Cannot string encode V0 in ${base.name} encoding`)}const cid=cache.get(prefix);if(cid==null){const cid=base.encode(bytes).slice(1);cache.set(prefix,cid);return cid}else{return cid}};const toStringV1=(bytes,cache,base)=>{const{prefix}=base;const cid=cache.get(prefix);if(cid==null){const cid=base.encode(bytes);cache.set(prefix,cid);return cid}else{return cid}};const DAG_PB_CODE=112;const SHA_256_CODE=18;const encodeCID=(version,code,multihash)=>{const codeOffset=varint_encodingLength(version);const hashOffset=codeOffset+varint_encodingLength(code);const bytes=new Uint8Array(hashOffset+multihash.byteLength);varint_encodeTo(version,bytes,0);varint_encodeTo(code,bytes,codeOffset);bytes.set(multihash,hashOffset);return bytes};const cidSymbol=Symbol.for("@ipld/js-cid/CID");const readonly={writable:false,configurable:false,enumerable:true};const hidden={writable:false,enumerable:false,configurable:false};const version="0.0.0-dev";const deprecate=(range,message)=>{if(range.test(version)){console.warn(message)}else{throw new Error(message)}};const IS_CID_DEPRECATION=`CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;export const digest_create=(code,digest)=>{const size=digest.byteLength;const sizeOffset=varint_encodingLength(code);const digestOffset=sizeOffset+varint_encodingLength(size);const bytes=new Uint8Array(digestOffset+size);varint_encodeTo(code,bytes,0);varint_encodeTo(size,bytes,sizeOffset);bytes.set(digest,digestOffset);return new Digest(code,size,digest,bytes)};export const digest_decode=multihash=>{const bytes=coerce(multihash);const[code,sizeOffset]=varint_decode(bytes);const[size,digestOffset]=varint_decode(bytes.subarray(sizeOffset));const digest=bytes.subarray(sizeOffset+digestOffset);if(digest.byteLength!==size){throw new Error("Incorrect length")}return new Digest(code,size,digest,bytes)};export const digest_equals=(a,b)=>{if(a===b){return true}else{return a.code===b.code&&a.size===b.size&&equalBytes(a.bytes,b.bytes)}};export class Digest{constructor(code,size,digest,bytes){this.code=code;this.size=size;this.digest=digest;this.bytes=bytes}}export const varint_decode=data=>{const code=vendor_varint.decode(data);return[code,vendor_varint.decode.bytes]};export const varint_encodeTo=(int,target,offset=0)=>{vendor_varint.encode(int,target,offset);return target};export const varint_encodingLength=int=>{return vendor_varint.encodingLength(int)};var encode_1=vendor_varint_encode;var MSB=128,REST=127,MSBALL=~REST,INT=Math.pow(2,31);function vendor_varint_encode(num,out,offset){out=out||[];offset=offset||0;var oldOffset=offset;while(num>=INT){out[offset++]=num&255|MSB;num/=128}while(num&MSBALL){out[offset++]=num&255|MSB;num>>>=7}out[offset]=num|0;encode.bytes=offset-oldOffset+1;return out}var vendor_varint_decode=read;var MSB$1=128,REST$1=127;function read(buf,offset){var res=0,offset=offset||0,shift=0,counter=offset,b,l=buf.length;do{if(counter>=l){read.bytes=0;throw new RangeError("Could not decode varint")}b=buf[counter++];res+=shift<28?(b&REST$1)<<shift:(b&REST$1)*Math.pow(2,shift);shift+=7}while(b>=MSB$1);read.bytes=counter-offset;return res}var N1=Math.pow(2,7);var N2=Math.pow(2,14);var N3=Math.pow(2,21);var N4=Math.pow(2,28);var N5=Math.pow(2,35);var N6=Math.pow(2,42);var N7=Math.pow(2,49);var N8=Math.pow(2,56);var N9=Math.pow(2,63);var length=function(value){return value<N1?1:value<N2?2:value<N3?3:value<N4?4:value<N5?5:value<N6?6:value<N7?7:value<N8?8:value<N9?9:10};var vendor_varint={encode:encode_1,decode:vendor_varint_decode,encodingLength:length};var _brrp_varint=vendor_varint;